Tips：
1、Ctrl+？：整体注释
2、print函数默认打印一行以后默认换行，若想不换行，在（）里面输入一个end=” “
例如：print（aaaa,end=” “） 简单换行可以执行一个print（“ “）打印一个空格就行，因为print函数自带了换行
3、运行时括号具有高优先级，执行顺序是从前往后。
  True or  ==> True
  True and ==>继续执行
  False or ==>继续执行
  False and ==> False
4、input输入的值为字符串类型
5、字符串类型有加法和乘法
6、字符串被赋值以后不能修改，只能重新赋值；列表里的元素可以被修改
7、一行代码过长，可加个 \ ，回车换行即可

一、注释
1、行注释：以#开头，单独成行或者在每行后面
2、块注释：以三个单引号或双引号开始和结束，中间任何内容机器无视

二、变量
 命名规则：1、可以是字母、数字加下划线，开头不能是数字
2、大小写有区别（Man和man不是同一个变量）
3、关键词不能用作变量
4、类名用大驼峰命名，普通变量单词间加下划线
三、数字类型：
1.十进制直接用数字表示；
2.二进制为以0b开头的一串01代码，如十进制的18为0b10010
3.八进制为以0o开头的0-7代码
4.十六进制为以0x开头的0-9加a-f代码
科学计数法，指数用e/E表示  如：123.45==1.2345e2   0.12345==1.2345e-1
复数：3+4j
  
布尔值：只有True和False两个值，True与1等值，False与0等值

字符串：用单引号和双引号括起来（一行）三引号（多行）
单双引号交错使用：html = ’a style ”color red”aaa’
 
转义字符：反斜杠\后的东西表示进行了转义，意义发生了变化
字符格式化：方式1：%   2：用format函数，大括号{}占位
%d：d代表需要一个整数；
%s：s代表需要一串字符串

运算符：
1.算数运算符：+-*/，取余%，商取整//，幂运算：**，2^3为2**3
2.比较运算符：== ， ！=，>，<,>=，<=  输出结果为布尔值True和False
3.赋值运算符：=，a+=7为a=a+7，相应的-=  *=等是一样的道理
4.逻辑运算符：与and，或or，非not  and相当于×，or相当于+
5.成员运算符：in和not in，在不在一个集合里面，输出结果为布尔值
6.身份运算符：is和is not，相同则输出True，反之。  

几个数字的函数用法：
1、int:转换为数字类型，如a=”123” b=int(a)； a是str，b转成了int类型
2、bit_length:当前数字的二进制，至少用几位表示。a=b.int_length()

三大结构：顺序 分支 循环

注意冒号不要遗漏

多路分支：
   elif后跟if后情况一样

Range(1,10)左闭右开，表示的是1到9，range（1,10,3）表示间隔为3,即1,4,7

Break：无条件结束整个循环
Continue：无条件结束本次循环，重新开始下一轮循环
Pass：表示略过
For循环：for xxx in[]:    变量常用i k m n



函数的调用: 函数名＋（）即可，括号内是否带参数取决于定义时是否带了

定义时 person 是形参，调用时 p 是实参
Return函数：立即返回，函数结束，后来的不会被执行了
注：print函数默认打印一行以后默认换行，若想不换行，在（）里面输入一个end=” “
例如：print（aaaa,end=” “） 简单换行可以执行一个print（“ “）打印一个空格就行，因为print函数自带了换行




位置参数：变量的位置很重要，与后面调用时值的先后顺序相关，定义几个调用时就必须出现几个（调用函数时所传参数的位置必须与定义函数时参数的位置相同）
默认参数：def name(a,b=2),b一开始的默认值就是2，是可选的，调用时b可不出现，调用时一般不重新赋值，并特殊标记好，因为是“默认参数”。与关键字参数的区别是它在定义函数的时候就赋值了，关键字参数是调用时再赋值
关键词参数： name(a,b=qwe) 后面调用可以修改，其余与默认参数相似
包裹参数：
1、包裹位置传递（传列表）：一颗星*用来接受可变数量参数（调用时可为空），根据传进参数的位置合并为一个元组(tuple)；*位置参数：可接受任意数量的位置参数(元组)；只能作为最后一个位置参数出现，其后参数均为关键字参数
2、包裹关键字传递（传字典）：两颗星**正常形参之外的其他的关键字参数都将被放置在一个字典中传递给函数 **关键字参数：可接受任意数量的关键字参数(字典)；只能作为最后一个参数出现
先位置参数，再关键字参数
def foo(x,*args,a=4,**kwargs):#使用默认参数时，注意默认参数的位置要在args之后kwargs之前
def foo(x,a=4,*args,**kwargs):##注意：当需要修改默认参数时，要调整默认参数的位置，要放在args之前即可，但不可放在开头。

列表不带*，会把这个列表当成是一个整体传进去，带*，会把列表里的元素一个一个传进去

数字类型操作：
1、bit_length:当前数字的二进制，至少用几位表示。a=b.int_length()
    字符串类型操作：
1、Capitalize：首个字母大写化，其余小写（title作用于整个字符串内的各个单词的首字母大写）
2、Casefold/lower（lower只对英文有用）：所有字母变小写（upper全部大写）
3、Center：设置宽度并将内容居中，v=aaa.center(10,*)，10指占位长度，*为其余位置的填充，可有可无，但只能是一个字符
4、Count：在字符串中找子序列出现的次数，a=”mmmaaa”,v=a.count(‘m’,1,3) 表示找出m的个数，起始位0，从第一个到第三个，3不包含，左开右闭（找ma也行）
5、Endswitch :以何结尾，输出结果是个布尔值（startswitch，以何开头）
6、Find：检测字符串中是否包含子字符串，如果有则返回最开始出现的子字符串的位置值，如果没有则返回-1（与count一样，起始位置为0，左开右闭）（index与find类似，但index找不到则会报错，不建议使用）
7、expandtabs() 方法把字符串中的 tab 符号('\t')转为空格，tab 符号('\t')默认的空格数是 8，8个一个单位，例如aaaaaa\t，则是有两个空格，因为a占了6个，（）里可设置数字
8、Format：格式化，先占位再赋值。
9、Isalnum：判断字符串中是否只含字母和数字，返回值为布尔值
10、Swapcase：用于对字符串的大小写字母进行转换，大变小，小变大
11、isidentifier() 方法用于判断字符串是否是有效的 Python 标识符，可用来判断变量名是否合法。返回布尔值
12、Isalpha：方法检测字符串是否只由字母组成；isdecimal：检查字符串是否只包含十进制字符；isdigit：字符串是否只由数字组成； islower() 方法检测字符串是否由小写字母组成； isnumeric() 方法检测字符串是否只由数字组成。这种方法是只针对unicode对象。Isprintable：是否存在不可显示的字符（如a\ta，\t打印是不可显示的）；isspace:判断是否全是空格；istitle:判断是否是标题的格式；
13、Jion:将字符串中的每一个元素按照指定分隔符进行拼接
14、Ljust：左边填充指定符号（rjust，右边）
15、Strip：去除首尾的空格和换行，括号里加相应字符的时候，则会去除原字符串的相应内容（lstrio,rstrip，去除左/右）
16、
17、Partition：从左向右，分割括号内的字符串，分成三份，rpartition从右。Slipt从左分割，括号内的字符串会被排除，指定的数字是分割几个的意思。Rslipt从右
18、Swapcase：交换大小写
19、Text=”Alex”,v=text[3],输出的是x，起始是0，v=text[0：2],输出的是al，[0:-1]除了最后一个
20、Len:获取当前字符串的字符数
21、Replace：***.replace（“a”,”b”,2）b替换a，从左开始替换两处

列表：
   用中括号扩起来，里面元素可以是字母 数字 字符串 布尔值和列表，用逗号隔开
可索引和切片，切片的结果也是一个列表。可for while循环。列表里的元素可以被修改和删除（del list[1]）。列表可以有加法（合并）和乘法（重复）。
1、字符串可转换为列表：a=”***”,b=list(a)
2、列表转为字符串：有数字和字符串时用for循环得到，
只有字符串时：a=[‘aa’,’bb’], b=’’.jion(a)
3、删除元素：del a[1]；增加元素：1.a.append(‘aa’) 2.a.extend([111])一个列表后面再加一个列表，append加的是元素 3.a.insert(1,‘sdd’) 数字是指定位置，须先指定，
4、修改元素：a[2]=’dd’ 直接改即可
5、Cmp(list1,list2) 前面大返回1，否则-1，相等0
6、Index:索引，寻找元素所在位置，没有的话会报错 
7、Count：查找元素出现的次数
8、Remove：移除列表中的某个值的第一个匹配项。（如有多个，移除第一个）
9、Resever：反向列表中元素
10、Pop:列表 pop() 方法通过指定元素的索引值来移除列表中的某个元素（默认是最后一个元素），并且返回该元素的值，如果列表为空或者索引值超出范围会报一个异常。


切片默认从左往右截取，从右往左会是空列表
元组：
   元组的第一级元素不能修改、增加或删除，可以索引和切片，可循环。元组和列表可以互相直接转换。元组转换为字符串时的操作与列表一样。
字典：
   列表和字典不能作为字典的key，value不限。字典是无序的。
1、字典for循环时默认是输出key的值，若想输出键值对，用aaa.items()
2、dict.fromkeys([‘aa’,’bb’],111)：根据序列创建字典，并指定统一的值
3、Get:根据key获取值，当key不存在时返回指定值。A=aaa.get(‘k1’,111)
4、Pop:删掉并获取值。V=aaa.pop(‘k1’)，删掉’k1’这个键值对并且把它给到v
5、Popitem:随机删除一个键值对
6、Setdefault：设置值，如果值存在，不设置并把对应key的值给到v,否则会添加这个新键值对并给到v。V=dict.setdefault（‘k11’,’111’）
7、Update：新输入的值，如有则更新，没有的则新添加
布尔值为假的情况：0，空的列表等 [] {} ()   none  空字符串“” 其余都是真
可变与不可变类型：重新赋值以后地址发生改变的为不可变，反之。。
可变：列表、字典
不可变：数字、字符串、元组
集合：1.由不同元素组成，2.无序，3.元素必须是不可变类型
集合生成方法，1.用大括号，a = {1,2,3}
2.用set函数，a = set([1,2,3])  （frozenset，创建一个不可变的集合）
1.add:添加内容 a.add() 一次只能添加一个值 update会更新多个值（可迭代）
2.Copy:复制，b=a.copy()
3.Remove: 删除，a.remove(1), 若元素不存在会报错，discard不会报错（Pop随机删）
4.求交集：①intersection，②用符号“&”
5.求并集：①union，②用符号“|”
6.差集：属于A但不属于B，①a.difference(b) ②用符号“-”
7.交叉补集：除了A和B的公共部分外的。a.symmetric_difference(b)（符号是^）
函数

注意：要写return，否则可能会没有一个返回值，显示None

在子程序里使用global可以重新定义全局变量
Nonlocal ：重新定义上一层的变量
全局变量名全用大写命名，局部变量用小写
程序执行到定义的函数时，不会执行但会进行编译，只有调用的时候才会执行
定义函数时可以嵌套函数，但是在最外面不能调用被嵌套的函数


变量作用域
Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。
变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：
L （Local） 局部作用域
E （Enclosing） 闭包函数外的函数中
G （Global） 全局作用域
B （Built-in） 内建作用域
以 L –> E –> G –>B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。
x = int(2.9)  # 内建作用域
Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这这些语句内定义的变量，外部也可以访问
a = 10def test():
    a = a + 1
    print(a)
test()
以上代码错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。
return func与return func()区别：带扩号返回的是func函数执行后的一个结果，不带则返回的仅是这个函数

注意上面两个，执行是一样的结果

递归：函数直接或间接地调用自身
递归深度默认是1000次，但是可以修改

eval 和 exec函数用法


eval函数：1.把字符串中的数据提取出来（如 eval”{‘aa’:’alex’}”会把这个字典提取出来提取出来,相当于引号去掉了2.把字符串中的表达式进行运算

Print(res())执行结果为None，因为test1没有返回值，如果是Print(res)，res没有括号，则是返回的是test1这个函数的内存地址

匿名函数：
lambda x:x+1
自动返回冒号后面的结果
高阶函数（含其一即可）：
1、函数接收的参数是一个函数名
2、返回值包含函数
map函数：
第一个参数为传入一个函数名（不要执行），第二个参数是可迭代对象
map内置函数里面有一个for循环，结果是一个迭代器
filter函数：
把可迭代对象a中的值给到前面的函数去处理，若结果是真，则会保留下来
reduce函数：把列表里的数据按指定函数的方式实现累积，要先导入reduce模块

1.函数，2.列表，3.可选的初始累积值
内置函数：
1、abs：绝对值，a=abs(-1)
2、all:一个可迭代对象里的元素都为真结果才是真，而空的可迭代对象返回是True,a=all([1,2,0])这个是false
3、any：一个可迭代对象里的元素只要有一个是真则返回真
4、bin:十进制转换为二进制（hex：十转十六，oct：十转八）
5、bool：判断布尔值
6、divmod:得到商和余数。Divmod(10,3)结果为(3,1)
7、hash:可hash的都是不可变类型，返回的是hash值
8、isinstane：判断前一个参数是否属于后面的类。Isinstance(1,int)返回True
9、zip:两个参数都是为序列，会一一对应组成一个元组(可用list函数把它显示出来) zip(*zipped) # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
10、max/min:不同数据类型不能比较，比较的时候是从第一个元素开始的，第一个比较出结果了后续就不用判断了，若第一个相同则看第二个。（字典默认比较的是key）

11、pow:  pow（2,3,2）：2**3%2 第三个参数可无
12、reversed：把列表里的元素反转
13、round：四舍五入
14、sorted:从小到大排序，复杂操作参考上面max那里的图
文件操作：

系统存的时候是以什么方式存的，解码需要指定相应的解码方式，默认是gbk解码打开。
1、readline：一次读取一行。若前面已经进行过read操作，则不会再读取了
2、readlines:逐行全读取出来，列表类型，一行就是列表的 一个元素（f.read()是把所有东西放在 一起，是字符串类型）
读模式只能读，写模式只能写。（with open ** as f 会自动执行f.close()）

‘w’模式下写的时候会把文件先清空一次再写，如果此文件没有则会新建一个空文件
‘a’模式下，在文件下紧接着追加写
‘r+’ 可读可写
‘rb’方式：以二进制方式读取，不能指定编码格式
tell:看目前光标移动到了哪个位置，字节位置
seek：控制光标的移动，字节位置（read读的是字符），seek(5,1):相对于上个位置往后移动五个位置，seek(-5,2):从最后倒着移动五个位置
truncate：需要在写模式下，截断，截断之后后面的所有字符被删除（不能用’w’模式写）
三元表达式：
If true返回前面的值，否则是else后的值

列表解析：
会生成一个列表
注意：当条件子句在for前时必须带上else，此时else表示不符合if条件时列表元素的取值；当条件子句在for后时不能带上else，下面两种是对的
[i if i%2==0 else -1 for i in range(7)]
[i for i in range(7) if i%2==0]
多重循环的列表解析式：
In [3]: [(i,j) for i in [1,3,5] for j in [2,4,6]]
Out[3]: [(1, 2), (1, 4), (1, 6), (3, 2), (3, 4), (3, 6), (5, 2), (5, 4), (5, 6)]


生成器：是一种数据类型，可直接使用next函数
生成器表达式：把列表解析的【】换成()即可，会节省内存（用yield也可得到一个生成器）


装饰器：本质就是函数，功能是为其他函数添加附加功能

装饰器=高阶函数+函数嵌套+闭包
装饰器基本实现：



导入自定义模块：
在最开始的import，会先把后面的模块文件先执行一遍并引入变量名
引用方式：1、import cal  之后 cal.add(3,5)
3、from cal import add  之后  add(3,5)  （from cal import *，意思是导入所有在cal文件中的函数，但是不推荐，因为会混淆函数名）
4、不同文件夹里的调用（只能从自己这一级向下）。若要导入上一级的模块，则需要进行操作添加相应路径
__name__的用法：


Time模块：结构化时间、时间戳、str时间转化
按指定格式输出时间：
print(time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time())))

Random模块：
random.random()：0-1之间的随机浮点数
1、Randint(1,3)是1-3之间包括3，randrange(1,3)不包含3（uniform是取范围内浮点数）
2、random:choice（[1,2,3]）随机取列表里的值
3、sample：sample([1,2,3,4],2)随机取两个，后面的数字‘2’控制个数

os模块：
os.path.dirname:找文件的上一级路径
os.path.abspath:找文件的绝对路径

json模块：
dumps:把所有类型都转换成其他语言也能识别的字符串类型
loads:与eval()功能类似但是更强大

re模块（正则表达式）
findall:匹配函数
. ：一个.代表一个字符。
^ ：^alex只匹配以alex开头的
$ : ..a$ 匹配以a结尾的
* ：a*，匹配0--∞个a,匹配不上的位置输出空字符串
+ ：a+，匹配1--∞个a,
？：a?，匹配0次或者1次，即做多1次
{}:{0,}取0到无穷大个，{0,2}取0-2个，默认取最大，{6}取6个重复的

re.findall(‘alex*?’,’alexxxxx’)，匹配结果为ale，变成惰性的了，也就是尽可能少
[]：或的意思，只能匹配里面的一个，除 -  ^ \ 外，其他元字符在[]内无效。[a-z]：a到z的任何一个都满足。[^az]，^的非的意思（非a非z就行）
\：能使有意义的字符变得无意义，无意义的字符变得有意义

注意：要匹配含‘\’的字符串时，需要输入四个反斜杠，因为python解释器和re模块都会进行转义，即转义两次。或者在字符串前加r，表示不转义
| :或。匹配|左右表达式任意一个，从左到右匹配，如果|没有包括在()中，则它的范围是整个正则表达式
():被括起来的表达式将作为分组，从表达式左边开始没遇到一个分组的左括号“（”，编号+1.
分组表达式作为一个整体，可以后接数量词。表达式中的|仅在该组中有效。
r ：将在python里有特殊意义的字符如\b，转换成原生字符（就是去除它在python的特殊意义），不然会给正则表达式有冲突，为了避免这种冲突可以在规则前加原始字符r
(?:)：当你要将一部分规则作为一个整体对它进行某些操作，比如指定其重复次数时，你需要将这部分规则用 ’(?:’ ‘)’ 把它包围起来，而不能仅仅只用一对括号，如匹配processing，直接匹配（ing）就不会匹配整个单了，加了(?:)就可匹配整个单词。（参考网址https://www.cnblogs.com/dreamer-fish/p/5282679.html）

Re模块的函数
match()函数是从内容的第一个字符开始匹配，如果匹配不到，就得到None 
search()函数从全部内容匹配，如果有多个，找到第一个匹配的 
findall()函数从全部内容匹配，如果有多个，找出所有匹配的
Split：split 方法按照能够匹配的子串将字符串分割后返回列表
Sub：用于替换字符串中的匹配项
Compile：函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。

Findall在遇到有分组的时候，会优先把分组的内容提取出来而不是所有的


logging模块：日志

面向对象
类：一个抽象概念，把一类事物的相同特征和动作整合到一起就是类
对象：基于类而创建的一个具体的事物，也就是动作和特征都包含在内
类与对象的关系：对象是由类产生的。由类生产对象的过程叫实例化。
注意：类名首个字母要大写

类的属性：1、数据属性（变量），2、函数属性（函数）
对象的属性：对象（实例）只有数据属性，没有函数属性（但是对象可以访问类属性，对象在自己的作用域里找不到变量的时候就去类里找，类里也找不到就会报错，它不能找到外面的全局变量的）。
两者都通过点来访问自己的属性。（a.bbb）
注意：只有当类和对象通过点的方式访问自己的属性时，才会从类里面找变量，否则不会在类里面找，而是从全局里去找

查看类的属性：dir(类名)
查看属性的字典：类名.__dict__  ，这会生成一个字典，key是属性名，value是属性值。下面是用__dict__方法调用类中的两个属性


__init__会自动传一个self函数进去，并且自动返回对象。
注意：对象在调用类的函数的时候，系统会自动把自己当成一个变量传进去，所以在定义类的函数时，括号内要加一个self参数；但是类调用类的函数时则需要自己传参数

@property可以把一个实例方法变成其同名属性，以支持.号访问
@classmethod : 不需要借助对象，类可直接访问类函数（一般是供类使用）
@staticmethod : 静态方法只是名义上的归属类管理，不能取类变量和实例变量，是类的工具包

继承：分为单继承和多继承，会继承父类里的所有属性。自己的属性在与父类的属性名重复时不会覆盖父类属性，找的时候先从自己这找
组合与继承：当类之间很大不同，并且小类是大类的一个组件的时候用组合；当类之间有很多相同的供能时用继承。
接口继承：实现归一化

继承顺序：先从子类开始招，父类找的顺序按照mro列表顺序找。Print(xx.__mro__)

子类中调用父类方法：super().父类名()，不用传self参数

多态：由不同的类实例化得到的对象，调用同一个方法，执行的逻辑不同。体现在执行上。

__getttr__  __delattr__和__setattr__ 是对象用点调用时触发，__getitem__等三个是字典形式调用才触发

Numpy
创建数组：ones zeros empty
array：里面加列表就会生成一个数组
arrange:与range类似
linsapce:生成等差数列
logspace:生成等比数列（默认底数是10，可通过base=*，来设定）
np.random.random((3,3)):随机生成一个0-1内的数组
np.random.randint(1,10,size=(3,3))，范围是1-10的整数
np.random.uniform(1,10,size=(3,3))，浮点数
np.random.randn((3,3)):随机生成一个0-1内的标准正态分布的数组（normal正态分布）
np.random.rand(9):随机生成一个0-1内的均分布9个随机数
数组之间的加减乘除是相应元素的运算，数组之间的矩阵积是arr1.dot(arr2)或np.dot(arr1,arr2)
数组的索引：获取某些数与列表索引类似，
1、arr1[0][0] 获取一整行：arr1[[0,3,5]]获取到了第1,4,6,这三行
2、arr1[0,3,5][0,3,2]是获取0,0 3,3 5,2 这三个数
3、arr1[np.ix_([0,3,5][0,3,2])]是获取第1行的第1,4,3（后面也是一样，第4,6行的那三个数据）
数组的切片：arr1[:][1,4] 冒号是指所有行，后面1，3指第2,3,列
矩阵转置：arr1.transpose()
4、最大值、最小值、平均值：arr1.max()  arr1.min()  arr1.mean() 在括号里加axis=0是针对列，=1是行。arr1.max(axis=0)这是取每一列的最大值 标准差：arr1.std() 方差：arr1.var()
5、where函数：与三元表达式类似。Where（条件，1,2）true返回1，false返回2 [xv if c else yv for (c,xv,yv) in zip(condition,x,y)]
6、Unique：去除重复数据
7、Eye:生成对角为1的数组
8、Mat:矩阵 矩阵的逆（a.I） 矩阵转置（a.T）矩阵相乘a*b 矩阵点乘 np.multiply（a,b） 矩阵的秩np.linalg.matrix_rank(a)  行列式：det 特征值与特征向量：eig  矩阵的操作在numpy.linalg 这个模块里面
9、举证求线性方程组：np.linalg.solve(a,b)  ax=b 只能求存在唯一解的情况，若解是无数的则会报错
10、random:choice（[1,2,3]）随机取列表里的值
11、在numpy数组切片时，a[:，1]与a[:][1] 是不一样的，前者是所有行的第2列，正常逻辑下要用第一种一个括号里面的



pandas
Series: 通过数组创建会默认索引从0开始，自己设置索引：arr1.index（）。也可通过字典的形式创建
isnull/notnull:过滤缺失值
自动对齐series01+series02，两者相同索引下的值相加，不同索引返回nan

dataframe:通过二位数组创建表格
索引：行索引：index  列索引：column 可修改，不修改默认从0开始
行获取：series01.loc   列获取：直接用字典的key值
文件读取：pd.read_csv  pd.read_excel 
dpopna:只要包含nan数据就删除掉
fillna:填充nan部分数据
cov:计算协方差
Corr：相关系数
用mean的时候axis=0是列，1是行 而在用dropna/drop的时候，axis=0 是删除一行，       =1是删除一列   默认是axis=0
在修改值的时候，DataFrame有点不一样，a.loc[1:2,1：2] 第1，2行与1,2列都会包括进来
a.head(6)表示显示前6行数据，若head()中不带参数则会显示全部数据。
a.Fillna(0) 会把所有nan数据替换为0
a.replace(‘?’,np.nan)所有？替换为nan
a.describe()：会把count mean 等基本数据显示出来(只能看数值型的)
pandas DataFrame数据转为list：
首先使用np.array()函数把DataFrame转化为np.ndarray()，再利用tolist()函数把np.ndarray()转为list
Pandas里的apply函数：函数的传入参数根据axis来定，比如axis = 1，就会把一行数据作为Series的数据结构传入给自己实现的函数中，我们在函数中实现对Series不同属性之间的计算，返回一个结果，则apply函数会自动遍历每一行DataFrame的数据，最后将所有结果组合成一个Series数据结构并返回。
 a[0:2]取前两行 a.iloc[0]取第一行 
 a[0]列没名字时取第一列 a[‘b’]列有名字时取‘b’列 a[[0,1]]第0,1列
a.iloc[:,[‘a’,’b’]]所有行的a b列 a.iloc[0:2,0:2]0-1行的0-1列 a.iloc[:,0:2] 第0-1列
获取dataframe的行：len(df)  获取列：df.columns.size

Matplotlib
导入：import matplotlib.pylot as plt
plt.plot:绘制线形图
show：显示
Figure：figure下面包含几个图就会显示几个图，要分开的话就多用几个figure函数
子图：plt.subplot(221) 两行两列的第一个位置
hist ：画柱状图
plt.xlim(-0.01, 1.02) 设置X轴的最大值和最小值
plt.xticks(np.arange(0, 1.1, 0.1)) 设置坐标轴的刻度
plt.pcolormesh()会根据y_predict的结果自动在cmap里选择颜色
## 设置字符集，防止中文乱码
mpl.rcParams['font.sans-serif']=[u'simHei']
mpl.rcParams['axes.unicode_minus']=False

快捷键：
Ctrl + E 　　　　可打开最近访问过的文件
Ctrl + Shift + E　打开最近编辑过的文件
万能搜索　shift连按两下
历史粘贴版　Ctrl + Shift + V
无论你的光标处在何位置，你都可以通过快捷键 Shfit + Enter 另起一行，这样无需把光标移到末尾去操作。
向下复制当前行　Ctrl + D
Ctrl + Shift + L　　格式化代码
Ctrl + Shift + +/- 展开/折叠全部代码块

